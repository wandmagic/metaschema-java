<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>IDefineableJsonSchema.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Metaschema XML and JSON Schema Generator</a> &gt; <a href="index.source.html" class="el_package">gov.nist.secauto.metaschema.schemagen.json</a> &gt; <span class="el_source">IDefineableJsonSchema.java</span></div><h1>IDefineableJsonSchema.java</h1><pre class="source lang-java linenums">/*
 * SPDX-FileCopyrightText: none
 * SPDX-License-Identifier: CC0-1.0
 */

package gov.nist.secauto.metaschema.schemagen.json;

import com.fasterxml.jackson.databind.node.ObjectNode;

import gov.nist.secauto.metaschema.core.model.IDefinition;
import gov.nist.secauto.metaschema.core.util.ObjectUtils;
import gov.nist.secauto.metaschema.schemagen.SchemaGenerationException;
import gov.nist.secauto.metaschema.schemagen.json.impl.AbstractDefinitionJsonSchema.SimpleKey;
import gov.nist.secauto.metaschema.schemagen.json.impl.AbstractModelDefinitionJsonSchema.ComplexKey;

import java.util.Comparator;

import edu.umd.cs.findbugs.annotations.NonNull;
import edu.umd.cs.findbugs.annotations.Nullable;

/**
 * Represents a JSON schema that is a global definition or an inline schema.
 * &lt;p&gt;
 * A schema of this type will be a global definition if
 * {@link #isInline(IJsonGenerationState)} is {@code false}.
 */
public interface IDefineableJsonSchema {

  /**
   * Determine if the schema is defined inline or as a global definition.
   *
   * @param state
   *          the schema generation state used for context
   * @return {@code true} if the schema is to be defined inline or {@code false}
   *         if the schema is to be defined globally
   */
  boolean isInline(@NonNull IJsonGenerationState state);

  default void generateSchemaOrRef(
      @NonNull ObjectNode obj,
      @NonNull IJsonGenerationState state) {
<span class="fc bfc" id="L42" title="All 2 branches covered.">    if (isInline(state)) {</span>
<span class="fc" id="L43">      generateInlineSchema(obj, state);</span>
    } else {
<span class="fc" id="L45">      generateRef(obj, state);</span>
    }
<span class="fc" id="L47">  }</span>

  /**
   * Generate the schema within the provided JSON object node.
   *
   * @param obj
   *          the JSON object to populate
   * @param state
   *          the schema generation state used for context and writing
   * @throws SchemaGenerationException
   *           if an error occurred while writing the type
   */
  void generateInlineSchema(
      @NonNull ObjectNode obj,
      @NonNull IJsonGenerationState state);

  /**
   * Get the definition's name.
   *
   * @param state
   *          the schema generation state used for context and writing
   * @return the definition name
   * @throws IllegalStateException
   *           if the JSON schema object is not a definition
   */
  @NonNull
  String getDefinitionName(@NonNull IJsonGenerationState state);

  /**
   * Get the definition's reference URI.
   *
   * @param state
   *          the schema generation state used for context and writing
   * @return the definition's reference URI
   * @throws IllegalStateException
   *           if the JSON schema object is not a definition
   */
  default String getDefinitionRef(@NonNull IJsonGenerationState state) {
<span class="nc" id="L85">    return ObjectUtils.notNull(new StringBuilder()</span>
<span class="nc" id="L86">        .append(&quot;#/definitions/&quot;)</span>
<span class="nc" id="L87">        .append(getDefinitionName(state))</span>
<span class="nc" id="L88">        .toString());</span>
  }

  /**
   * Generate a reference to a globally defined schema, within the provided JSON
   * object node.
   *
   * @param obj
   *          the JSON object to populate
   * @param state
   *          the schema generation state used for context and writing
   * @throws SchemaGenerationException
   *           if an error occurred while writing the type
   */
  default void generateRef(
      @NonNull ObjectNode obj,
      @NonNull IJsonGenerationState state) {
<span class="fc" id="L105">    obj.put(&quot;$ref&quot;, getDefinitionRef(state));</span>
<span class="fc" id="L106">  }</span>

  // /**
  // * Determine if the JSON schema object is a JSON definition.
  // *
  // * @param state
  // * the schema generation state used for context and writing
  // * @return {@code true} if the SON schema object is a definition or
  // * {@code false} otherwise
  // */
  // default boolean isDefinition(@NonNull IJsonGenerationState state) {
  // return !isInline(state);
  // }

  // REFACTOR: move to abstract implementation?
  default void generateDefinition(@NonNull IJsonGenerationState state, @NonNull ObjectNode definitionsObject) {

    // create the definition property
<span class="fc" id="L124">    ObjectNode definitionObj = ObjectUtils.notNull(</span>
<span class="fc" id="L125">        definitionsObject.putObject(getDefinitionName(state)));</span>

    // Add identifier, see usnistgov/metaschema#160
<span class="fc" id="L128">    definitionObj.put(&quot;$id&quot;, getDefinitionRef(state));</span>

    // generate the definition object contents
<span class="fc" id="L131">    generateInlineSchema(definitionObj, state);</span>
<span class="fc" id="L132">  }</span>

  interface IKey extends Comparable&lt;IKey&gt; {
<span class="fc" id="L135">    Comparator&lt;IKey&gt; KEY_COMPARATOR = Comparator</span>
<span class="pc" id="L136">        .&lt;IKey, String&gt;comparing(key -&gt; key.getDefinition().getContainingModule().getShortName())</span>
<span class="pc" id="L137">        .thenComparing(key -&gt; key.getDefinition().getEffectiveName())</span>
<span class="fc" id="L138">        .thenComparing(IKey::getJsonKeyFlagName, Comparator.nullsFirst(Comparator.naturalOrder()))</span>
<span class="fc" id="L139">        .thenComparing(IKey::getDiscriminatorProperty, Comparator.nullsFirst(Comparator.naturalOrder()))</span>
<span class="fc" id="L140">        .thenComparing(IKey::getDiscriminatorValue, Comparator.nullsFirst(Comparator.naturalOrder()));</span>

    @NonNull
    static IKey of(@NonNull IDefinition definition) {
<span class="fc" id="L144">      return new SimpleKey(definition);</span>
    }

    @NonNull
    static IKey of(
        @NonNull IDefinition definition,
        @Nullable String jsonKeyFlagName,
        @Nullable String discriminatorProperty,
        @Nullable String discriminatorValue) {
      IKey retval;
<span class="pc bpc" id="L154" title="1 of 6 branches missed.">      if (jsonKeyFlagName != null || discriminatorProperty != null || discriminatorValue != null) {</span>
<span class="fc" id="L155">        retval = new ComplexKey(definition, jsonKeyFlagName, discriminatorProperty, discriminatorValue);</span>
      } else {
<span class="fc" id="L157">        retval = new SimpleKey(definition);</span>
      }
<span class="fc" id="L159">      return retval;</span>
    }

    @NonNull
    IDefinition getDefinition();

    @Nullable
    String getJsonKeyFlagName();

    @Nullable
    String getDiscriminatorProperty();

    @Nullable
    String getDiscriminatorValue();

    @Override
    default int compareTo(IKey other) {
<span class="nc" id="L176">      return KEY_COMPARATOR.compare(this, other);</span>
    }
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>