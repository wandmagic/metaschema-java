<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>IFunction.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Metaschema Core API</a> &gt; <a href="index.source.html" class="el_package">gov.nist.secauto.metaschema.core.metapath.function</a> &gt; <span class="el_source">IFunction.java</span></div><h1>IFunction.java</h1><pre class="source lang-java linenums">/*
 * SPDX-FileCopyrightText: none
 * SPDX-License-Identifier: CC0-1.0
 */

package gov.nist.secauto.metaschema.core.metapath.function;

import gov.nist.secauto.metaschema.core.metapath.DynamicContext;
import gov.nist.secauto.metaschema.core.metapath.ISequence;
import gov.nist.secauto.metaschema.core.metapath.MetapathException;
import gov.nist.secauto.metaschema.core.metapath.item.IItem;
import gov.nist.secauto.metaschema.core.util.ObjectUtils;

import java.net.URI;
import java.util.ArrayList;
import java.util.EnumSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Objects;
import java.util.Set;
import java.util.stream.Collectors;

import javax.xml.namespace.QName;

import edu.umd.cs.findbugs.annotations.NonNull;

/**
 * A common interface for all Metapath functions.
 */
public interface IFunction {
  /**
   * Details specific characteristics of a function.
   */
<span class="fc" id="L34">  enum FunctionProperty {</span>
    /**
     * Indicates that the function will produce identical results for the same
     * arguments (see XPath 3.1 &lt;a href=
     * &quot;https://www.w3.org/TR/xpath-functions-31/#dt-deterministic&quot;&gt;deterministic&lt;/a&gt;).
     * If not assigned to a function definition, a function call with the same
     * arguments is not guaranteed to produce the same results in the same order for
     * subsequent calls within the same execution context.
     */
<span class="fc" id="L43">    DETERMINISTIC,</span>
    /**
     * Indicates that the result of the function depends on property values within
     * the static or dynamic context and the provided arguments (see XPath 3.1
     * &lt;a href=
     * &quot;https://www.w3.org/TR/xpath-functions-31/#dt-context-dependent&quot;&gt;context-dependent&lt;/a&gt;).
     * If not assigned to a function definition, a call will not be affected by the
     * property values within the static or dynamic context and will not have any
     * arguments.
     */
<span class="fc" id="L53">    CONTEXT_DEPENDENT,</span>
    /**
     * Indicates that the result of the function depends on the current focus (see
     * XPath 3.1 &lt;a href=
     * &quot;https://www.w3.org/TR/xpath-functions-31/#dt-focus-independent&quot;&gt;focus-dependent&lt;/a&gt;).
     * If not assigned to a function definition, a call will not be affected by the
     * current focus.
     */
<span class="fc" id="L61">    FOCUS_DEPENDENT,</span>
    /**
     * The function allows the last argument to be repeated any number of times.
     */
<span class="fc" id="L65">    UNBOUNDED_ARITY;</span>
  }

  /**
   * Retrieve the name of the function.
   *
   * @return the function's name
   */
  @NonNull
  default String getName() {
<span class="fc" id="L75">    return ObjectUtils.notNull(getQName().getLocalPart());</span>
  }

  /**
   * Retrieve the namespace qualified name of the function.
   *
   * @return the namespace qualified name
   */
  @NonNull
  QName getQName();

  /**
   * Retrieve the set of assigned function properties.
   *
   * @return the set of properties or an empty set
   */
  @NonNull
  Set&lt;FunctionProperty&gt; getProperties();

  /**
   * Retrieve the list of function arguments.
   *
   * @return the function arguments or an empty list if there are none
   */
  @NonNull
  List&lt;IArgument&gt; getArguments();

  /**
   * Determine the number of arguments the function has.
   *
   * @return the number of function arguments
   */
  int arity();

  /**
   * Determines if the result of the function call will produce identical results
   * when provided the same implicit or explicit arguments.
   *
   * @return {@code true} if function is deterministic or {@code false} otherwise
   * @see FunctionProperty#DETERMINISTIC
   */
  default boolean isDeterministic() {
<span class="fc" id="L117">    return getProperties().contains(FunctionProperty.DETERMINISTIC);</span>
  }

  /**
   * Determines if the result of the function call depends on property values
   * within the static or dynamic context and the provided arguments.
   *
   * @return {@code true} if function is context dependent or {@code false}
   *         otherwise
   * @see FunctionProperty#CONTEXT_DEPENDENT
   */
  default boolean isContextDepenent() {
<span class="nc" id="L129">    return getProperties().contains(FunctionProperty.CONTEXT_DEPENDENT);</span>
  }

  /**
   * Determines if the result of the function call depends on the current focus.
   *
   * @return {@code true} if function is focus dependent or {@code false}
   *         otherwise
   * @see FunctionProperty#FOCUS_DEPENDENT
   */
  default boolean isFocusDepenent() {
<span class="fc" id="L140">    return getProperties().contains(FunctionProperty.FOCUS_DEPENDENT);</span>
  }

  /**
   * Determines if the final argument can be repeated.
   *
   * @return {@code true} if the final argument can be repeated or {@code false}
   *         otherwise
   * @see FunctionProperty#UNBOUNDED_ARITY
   */
  default boolean isArityUnbounded() {
<span class="fc" id="L151">    return getProperties().contains(FunctionProperty.UNBOUNDED_ARITY);</span>
  }

  /**
   * Retrieve the function result sequence type.
   *
   * @return the function result sequence type
   */
  @NonNull
  ISequenceType getResult();

  // /**
  // * Determines by static analysis if the function supports the expression
  // arguments provided.
  // *
  // * @param arguments
  // * the expression arguments to evaluate
  // * @return {@code true} if the arguments are supported or {@code false}
  // otherwise
  // */
  // boolean isSupported(List&lt;IExpression&lt;?&gt;&gt; arguments);

  /**
   * Execute the function with the provided {@code arguments}, using the provided
   * {@code DynamicContext} and {@code focus}.
   *
   * @param arguments
   *          the function arguments or an empty list if there are no arguments
   * @param dynamicContext
   *          the dynamic evaluation context
   * @param focus
   *          the current focus or an empty sequence if there is no focus
   * @return the function result
   * @throws MetapathException
   *           if an error occurred while executing the function
   */
  @NonNull
  ISequence&lt;?&gt; execute(
      @NonNull List&lt;ISequence&lt;?&gt;&gt; arguments,
      @NonNull DynamicContext dynamicContext,
      @NonNull ISequence&lt;?&gt; focus);

  /**
   * Get the signature of the function as a string.
   *
   * @return the signature
   */
  @NonNull
  default String toSignature() {
<span class="fc" id="L200">    return ObjectUtils.notNull(String.format(&quot;%s(%s) as %s&quot;,</span>
<span class="fc" id="L201">        getQName(),</span>
<span class="pc bpc" id="L202" title="1 of 2 branches missed.">        getArguments().isEmpty() ? &quot;&quot;</span>
<span class="fc" id="L203">            : getArguments().stream().map(IArgument::toSignature).collect(Collectors.joining(&quot;,&quot;))</span>
<span class="pc bpc" id="L204" title="1 of 2 branches missed.">                + (isArityUnbounded() ? &quot;, ...&quot; : &quot;&quot;),</span>
<span class="fc" id="L205">        getResult().toSignature()));</span>
  }

  /**
   * Construct a new function signature builder.
   *
   * @return the new builder instance
   */
  @NonNull
  static Builder builder() {
<span class="fc" id="L215">    return new Builder();</span>
  }

  /**
   * Used to create a function's signature using a builder pattern.
   */
  @SuppressWarnings(&quot;PMD.LooseCoupling&quot;)
  final class Builder {
    private String name;
    private String namespace;
<span class="fc" id="L225">    @SuppressWarnings(&quot;null&quot;)</span>
    @NonNull
<span class="fc" id="L227">    private final EnumSet&lt;FunctionProperty&gt; properties = EnumSet.noneOf(FunctionProperty.class);</span>
<span class="fc" id="L228">    @NonNull</span>
    private final List&lt;IArgument&gt; arguments = new LinkedList&lt;&gt;();
<span class="fc" id="L230">    @NonNull</span>
    private Class&lt;? extends IItem&gt; returnType = IItem.class;
<span class="fc" id="L232">    @NonNull</span>
    private Occurrence returnOccurrence = Occurrence.ONE;
    private IFunctionExecutor functionHandler;

<span class="fc" id="L236">    private Builder() {</span>
      // do nothing
<span class="fc" id="L238">    }</span>

    /**
     * Define the name of the function.
     *
     * @param name
     *          the function's name
     * @return this builder
     */
    @NonNull
    public Builder name(@NonNull String name) {
<span class="fc" id="L249">      Objects.requireNonNull(name, &quot;name&quot;);</span>
<span class="pc bpc" id="L250" title="1 of 2 branches missed.">      if (name.isBlank()) {</span>
<span class="nc" id="L251">        throw new IllegalArgumentException(&quot;the name must be non-blank&quot;);</span>
      }
<span class="fc" id="L253">      this.name = name.trim();</span>
<span class="fc" id="L254">      return this;</span>
    }

    /**
     * Define the namespace of the function.
     *
     * @param uri
     *          the function's namespace URI
     * @return this builder
     */
    @NonNull
    public Builder namespace(@NonNull URI uri) {
<span class="fc" id="L266">      return namespace(ObjectUtils.notNull(uri.toASCIIString()));</span>
    }

    /**
     * Define the namespace of the function.
     *
     * @param name
     *          the function's namespace URI as a string
     * @return this builder
     */
    @NonNull
    public Builder namespace(@NonNull String name) {
<span class="fc" id="L278">      Objects.requireNonNull(name, &quot;name&quot;);</span>
<span class="pc bpc" id="L279" title="1 of 2 branches missed.">      if (name.isBlank()) {</span>
<span class="nc" id="L280">        throw new IllegalArgumentException(&quot;the name must be non-blank&quot;);</span>
      }
<span class="fc" id="L282">      this.namespace = name.trim();</span>
<span class="fc" id="L283">      return this;</span>
    }

    /**
     * Mark the function as deterministic.
     *
     * @return this builder
     * @see IFunction.FunctionProperty#DETERMINISTIC
     */
    @NonNull
    public Builder deterministic() {
<span class="fc" id="L294">      properties.add(FunctionProperty.DETERMINISTIC);</span>
<span class="fc" id="L295">      return this;</span>
    }

    /**
     * Mark the function as non-deterministic.
     *
     * @return this builder
     * @see IFunction.FunctionProperty#DETERMINISTIC
     */
    @NonNull
    public Builder nonDeterministic() {
<span class="nc" id="L306">      properties.remove(FunctionProperty.DETERMINISTIC);</span>
<span class="nc" id="L307">      return this;</span>
    }

    /**
     * Mark the function as context dependent.
     *
     * @return this builder
     * @see IFunction.FunctionProperty#CONTEXT_DEPENDENT
     */
    @NonNull
    public Builder contextDependent() {
<span class="fc" id="L318">      properties.add(FunctionProperty.CONTEXT_DEPENDENT);</span>
<span class="fc" id="L319">      return this;</span>
    }

    /**
     * Mark the function as context independent.
     *
     * @return this builder
     * @see IFunction.FunctionProperty#CONTEXT_DEPENDENT
     */
    @NonNull
    public Builder contextIndependent() {
<span class="fc" id="L330">      properties.remove(FunctionProperty.CONTEXT_DEPENDENT);</span>
<span class="fc" id="L331">      return this;</span>
    }

    /**
     * Mark the function as focus dependent.
     *
     * @return this builder
     * @see IFunction.FunctionProperty#FOCUS_DEPENDENT
     */
    @NonNull
    public Builder focusDependent() {
<span class="fc" id="L342">      properties.add(FunctionProperty.FOCUS_DEPENDENT);</span>
<span class="fc" id="L343">      return this;</span>
    }

    /**
     * Mark the function as focus independent.
     *
     * @return this builder
     * @see IFunction.FunctionProperty#FOCUS_DEPENDENT
     */
    @NonNull
    public Builder focusIndependent() {
<span class="fc" id="L354">      properties.remove(FunctionProperty.FOCUS_DEPENDENT);</span>
<span class="fc" id="L355">      return this;</span>
    }

    /**
     * Indicate if the last argument can be repeated.
     *
     * @param allow
     *          if {@code true} then the the last argument can be repeated an
     *          unlimited number of times, or {@code false} otherwise
     * @return this builder
     */
    @NonNull
    public Builder allowUnboundedArity(boolean allow) {
<span class="pc bpc" id="L368" title="1 of 2 branches missed.">      if (allow) {</span>
<span class="fc" id="L369">        properties.add(FunctionProperty.UNBOUNDED_ARITY);</span>
      } else {
<span class="nc" id="L371">        properties.remove(FunctionProperty.UNBOUNDED_ARITY);</span>
      }
<span class="fc" id="L373">      return this;</span>
    }

    /**
     * Define the return sequence Java type of the function.
     *
     * @param type
     *          the function's return Java type
     * @return this builder
     */
    @NonNull
    public Builder returnType(@NonNull Class&lt;? extends IItem&gt; type) {
<span class="fc" id="L385">      Objects.requireNonNull(type, &quot;type&quot;);</span>
<span class="fc" id="L386">      this.returnType = type;</span>
<span class="fc" id="L387">      return this;</span>
    }

    /**
     * Indicate the sequence returned will contain zero or one items.
     *
     * @return this builder
     */
    @NonNull
    public Builder returnZeroOrOne() {
<span class="fc" id="L397">      return returnOccurrence(Occurrence.ZERO_OR_ONE);</span>
    }

    /**
     * Indicate the sequence returned will contain one item.
     *
     * @return this builder
     */
    @NonNull
    public Builder returnOne() {
<span class="fc" id="L407">      return returnOccurrence(Occurrence.ONE);</span>
    }

    /**
     * Indicate the sequence returned will contain zero or more items.
     *
     * @return this builder
     */
    @NonNull
    public Builder returnZeroOrMore() {
<span class="fc" id="L417">      return returnOccurrence(Occurrence.ZERO_OR_MORE);</span>
    }

    /**
     * Indicate the sequence returned will contain one or more items.
     *
     * @return this builder
     */
    @NonNull
    public Builder returnOneOrMore() {
<span class="nc" id="L427">      return returnOccurrence(Occurrence.ONE_OR_MORE);</span>
    }

    @NonNull
    private Builder returnOccurrence(@NonNull Occurrence occurrence) {
<span class="fc" id="L432">      Objects.requireNonNull(occurrence, &quot;occurrence&quot;);</span>
<span class="fc" id="L433">      this.returnOccurrence = occurrence;</span>
<span class="fc" id="L434">      return this;</span>
    }

    /**
     * Add an argument based on the provided {@code builder}.
     *
     * @param builder
     *          the argument builder
     * @return this builder
     */
    @NonNull
    public Builder argument(@NonNull IArgument.Builder builder) {
<span class="nc" id="L446">      return argument(builder.build());</span>
    }

    /**
     * Add an argument based on the provided {@code argument} signature.
     *
     * @param argument
     *          the argument
     * @return this builder
     */
    @NonNull
    public Builder argument(@NonNull IArgument argument) {
<span class="fc" id="L458">      Objects.requireNonNull(argument, &quot;argument&quot;);</span>
<span class="fc" id="L459">      this.arguments.add(argument);</span>
<span class="fc" id="L460">      return this;</span>
    }

    /**
     * Specify the static function to call when executing the function.
     *
     * @param handler
     *          a method implementing the {@link IFunctionExecutor} functional
     *          interface
     * @return this builder
     */
    @NonNull
    public Builder functionHandler(@NonNull IFunctionExecutor handler) {
<span class="fc" id="L473">      Objects.requireNonNull(handler, &quot;handler&quot;);</span>
<span class="fc" id="L474">      this.functionHandler = handler;</span>
<span class="fc" id="L475">      return this;</span>
    }

    /**
     * Builds the function's signature.
     *
     * @return the function's signature
     */
    @NonNull
    public IFunction build() {
<span class="pc bpc" id="L485" title="1 of 4 branches missed.">      if (properties.contains(FunctionProperty.UNBOUNDED_ARITY) &amp;&amp; arguments.isEmpty()) {</span>
<span class="nc" id="L486">        throw new IllegalStateException(&quot;to allow unbounded arity, at least one argument must be provided&quot;);</span>
      }

<span class="fc" id="L489">      return new DefaultFunction(</span>
<span class="fc" id="L490">          ObjectUtils.requireNonNull(name, &quot;the name must not be null&quot;),</span>
<span class="fc" id="L491">          ObjectUtils.requireNonNull(namespace, &quot;the namespace must not be null&quot;),</span>
          properties,
          new ArrayList&lt;&gt;(arguments),
<span class="fc" id="L494">          ISequenceType.of(returnType, returnOccurrence),</span>
<span class="fc" id="L495">          ObjectUtils.requireNonNull(functionHandler, &quot;the function handler must not be null&quot;));</span>
    }
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>