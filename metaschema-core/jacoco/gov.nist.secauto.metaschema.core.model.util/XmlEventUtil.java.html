<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>XmlEventUtil.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Metaschema Core API</a> &gt; <a href="index.source.html" class="el_package">gov.nist.secauto.metaschema.core.model.util</a> &gt; <span class="el_source">XmlEventUtil.java</span></div><h1>XmlEventUtil.java</h1><pre class="source lang-java linenums">/*
 * SPDX-FileCopyrightText: none
 * SPDX-License-Identifier: CC0-1.0
 */

package gov.nist.secauto.metaschema.core.model.util;

import gov.nist.secauto.metaschema.core.util.ObjectUtils;

import org.codehaus.stax2.XMLEventReader2;
import org.codehaus.stax2.XMLStreamReader2;

import java.io.IOException;
import java.util.HashMap;
import java.util.Map;
import java.util.Set;
import java.util.regex.Pattern;
import java.util.stream.Collectors;
import java.util.stream.IntStream;

import javax.xml.namespace.QName;
import javax.xml.stream.Location;
import javax.xml.stream.XMLStreamConstants;
import javax.xml.stream.XMLStreamException;
import javax.xml.stream.events.Characters;
import javax.xml.stream.events.EndElement;
import javax.xml.stream.events.StartElement;
import javax.xml.stream.events.XMLEvent;

import edu.umd.cs.findbugs.annotations.NonNull;
import edu.umd.cs.findbugs.annotations.Nullable;

public final class XmlEventUtil { // NOPMD this is a set of utility methods
<span class="fc" id="L34">  private static final Pattern WHITESPACE_ONLY = Pattern.compile(&quot;^\\s+$&quot;);</span>

<span class="fc" id="L36">  private static final Map&lt;Integer, String&gt; EVENT_NAME_MAP = new HashMap&lt;&gt;(); // NOPMD - this value is immutable</span>

  static {
<span class="fc" id="L39">    EVENT_NAME_MAP.put(XMLStreamConstants.START_ELEMENT, &quot;START_ELEMENT&quot;);</span>
<span class="fc" id="L40">    EVENT_NAME_MAP.put(XMLStreamConstants.END_ELEMENT, &quot;END_ELEMENT&quot;);</span>
<span class="fc" id="L41">    EVENT_NAME_MAP.put(XMLStreamConstants.PROCESSING_INSTRUCTION, &quot;PROCESSING_INSTRUCTION&quot;);</span>
<span class="fc" id="L42">    EVENT_NAME_MAP.put(XMLStreamConstants.CHARACTERS, &quot;CHARACTERS&quot;);</span>
<span class="fc" id="L43">    EVENT_NAME_MAP.put(XMLStreamConstants.COMMENT, &quot;COMMENT&quot;);</span>
<span class="fc" id="L44">    EVENT_NAME_MAP.put(XMLStreamConstants.SPACE, &quot;SPACE&quot;);</span>
<span class="fc" id="L45">    EVENT_NAME_MAP.put(XMLStreamConstants.START_DOCUMENT, &quot;START_DOCUMENT&quot;);</span>
<span class="fc" id="L46">    EVENT_NAME_MAP.put(XMLStreamConstants.END_DOCUMENT, &quot;END_DOCUMENT&quot;);</span>
<span class="fc" id="L47">    EVENT_NAME_MAP.put(XMLStreamConstants.ENTITY_REFERENCE, &quot;ENTITY_REFERENCE&quot;);</span>
<span class="fc" id="L48">    EVENT_NAME_MAP.put(XMLStreamConstants.ATTRIBUTE, &quot;ATTRIBUTE&quot;);</span>
<span class="fc" id="L49">    EVENT_NAME_MAP.put(XMLStreamConstants.DTD, &quot;DTD&quot;);</span>
<span class="fc" id="L50">    EVENT_NAME_MAP.put(XMLStreamConstants.CDATA, &quot;CDATA&quot;);</span>
<span class="fc" id="L51">    EVENT_NAME_MAP.put(XMLStreamConstants.NAMESPACE, &quot;XML_NAMESPACE&quot;);</span>
<span class="fc" id="L52">    EVENT_NAME_MAP.put(XMLStreamConstants.NOTATION_DECLARATION, &quot;NOTATION_DECLARATION&quot;);</span>
<span class="fc" id="L53">    EVENT_NAME_MAP.put(XMLStreamConstants.ENTITY_DECLARATION, &quot;ENTITY_DECLARATION&quot;);</span>
<span class="fc" id="L54">  }</span>

  private XmlEventUtil() {
    // disable construction
  }

  @SuppressWarnings(&quot;null&quot;)
  @NonNull
  private static Object escape(@NonNull String data) {
<span class="nc" id="L63">    return data.chars()</span>
<span class="nc" id="L64">        .mapToObj(c -&gt; (char) c)</span>
<span class="nc" id="L65">        .map(XmlEventUtil::escape).collect(Collectors.joining());</span>
  }

  @SuppressWarnings(&quot;null&quot;)
  @NonNull
  private static String escape(char ch) {
    String retval;
<span class="nc bnc" id="L72" title="All 3 branches missed.">    switch (ch) {</span>
    case '\n':
<span class="nc" id="L74">      retval = &quot;\\n&quot;;</span>
<span class="nc" id="L75">      break;</span>
    case '\r':
<span class="nc" id="L77">      retval = &quot;\\r&quot;;</span>
<span class="nc" id="L78">      break;</span>
    default:
<span class="nc" id="L80">      retval = String.valueOf(ch);</span>
      break;
    }
<span class="nc" id="L83">    return retval;</span>
  }

  /**
   * Generate a message suitable for logging that describes the provided
   * {@link XMLEvent}.
   *
   * @param xmlEvent
   *          the XML event to generate the message for
   * @return the message
   */
  @NonNull
  public static CharSequence toString(XMLEvent xmlEvent) {
    CharSequence retval;
<span class="pc bpc" id="L97" title="1 of 2 branches missed.">    if (xmlEvent == null) {</span>
<span class="nc" id="L98">      retval = &quot;EOF&quot;;</span>
    } else {
      @SuppressWarnings(&quot;null&quot;)
<span class="fc" id="L101">      @NonNull StringBuilder builder = new StringBuilder()</span>
<span class="fc" id="L102">          .append(toEventName(xmlEvent));</span>
<span class="fc" id="L103">      QName name = toQName(xmlEvent);</span>
<span class="fc bfc" id="L104" title="All 2 branches covered.">      if (name != null) {</span>
<span class="fc" id="L105">        builder.append(&quot;: &quot;).append(name.toString());</span>
      }
<span class="pc bpc" id="L107" title="1 of 2 branches missed.">      if (xmlEvent.isCharacters()) {</span>
<span class="nc" id="L108">        String text = xmlEvent.asCharacters().getData();</span>
<span class="nc bnc" id="L109" title="All 2 branches missed.">        if (text != null) {</span>
<span class="nc" id="L110">          builder.append(&quot; '&quot;).append(escape(text)).append('\'');</span>
        }
      }
<span class="fc" id="L113">      Location location = toLocation(xmlEvent);</span>
<span class="fc bfc" id="L114" title="All 2 branches covered.">      if (location != null) {</span>
<span class="fc" id="L115">        builder.append(&quot; at &quot;).append(toString(location));</span>
      }
<span class="fc" id="L117">      retval = builder;</span>
    }
<span class="fc" id="L119">    return retval;</span>
  }

  /**
   * Generates a message for the provided {@link Location}.
   *
   * @param location
   *          the location to generate the message for
   * @return the message
   */
  @SuppressWarnings(&quot;null&quot;)
  @NonNull
  public static CharSequence toString(@Nullable Location location) {
<span class="pc bpc" id="L132" title="1 of 2 branches missed.">    return location == null ? &quot;unknown&quot;</span>
        : new StringBuilder()
<span class="fc" id="L134">            .append(location.getLineNumber())</span>
<span class="fc" id="L135">            .append(':')</span>
<span class="fc" id="L136">            .append(location.getColumnNumber());</span>
  }

  /**
   * Generates a string containing the current event and location of the stream
   * reader.
   *
   * @param reader
   *          the XML event stream reader
   * @return the generated string
   */
  @NonNull
  public static CharSequence toString(@NonNull XMLStreamReader2 reader) { // NO_UCD (unused code)
<span class="nc" id="L149">    int type = reader.getEventType();</span>

    @SuppressWarnings(&quot;null&quot;)
<span class="nc" id="L152">    @NonNull StringBuilder builder = new StringBuilder().append(toEventName(type));</span>
<span class="nc" id="L153">    QName name = reader.getName();</span>
<span class="nc bnc" id="L154" title="All 2 branches missed.">    if (name != null) {</span>
<span class="nc" id="L155">      builder.append(&quot;: &quot;).append(name.toString());</span>
    }
<span class="nc bnc" id="L157" title="All 2 branches missed.">    if (XMLStreamConstants.CHARACTERS == type) {</span>
<span class="nc" id="L158">      String text = reader.getText();</span>
<span class="nc bnc" id="L159" title="All 2 branches missed.">      if (text != null) {</span>
<span class="nc" id="L160">        builder.append(&quot; '&quot;).append(escape(text)).append('\'');</span>
      }
    }
<span class="nc" id="L163">    Location location = reader.getLocation();</span>
<span class="nc bnc" id="L164" title="All 2 branches missed.">    if (location != null) {</span>
<span class="nc" id="L165">      builder.append(&quot; at &quot;).append(toString(location));</span>
    }
<span class="nc" id="L167">    return builder;</span>
  }

  /**
   * Retrieve the resource location of {@code event}.
   *
   * @param event
   *          the XML event to identify the location for
   * @return the location or {@code null} if the location is unknown
   */
  @Nullable
  public static Location toLocation(@NonNull XMLEvent event) {
<span class="fc" id="L179">    Location retval = null;</span>
<span class="fc bfc" id="L180" title="All 2 branches covered.">    if (event.isStartElement()) {</span>
<span class="fc" id="L181">      StartElement start = event.asStartElement();</span>
<span class="fc" id="L182">      retval = start.getLocation();</span>
<span class="pc bpc" id="L183" title="1 of 2 branches missed.">    } else if (event.isEndElement()) {</span>
<span class="nc" id="L184">      EndElement end = event.asEndElement();</span>
<span class="nc" id="L185">      retval = end.getLocation();</span>
<span class="pc bpc" id="L186" title="1 of 2 branches missed.">    } else if (event.isCharacters()) {</span>
<span class="nc" id="L187">      Characters characters = event.asCharacters();</span>
<span class="nc" id="L188">      retval = characters.getLocation();</span>
    }
<span class="fc" id="L190">    return retval;</span>
  }

  /**
   * Retrieve the name of the node associated with {@code event}.
   *
   * @param event
   *          the XML event to get the {@link QName} for
   * @return the name of the node or {@code null} if the event is not a start or
   *         end element
   */
  @Nullable
  public static QName toQName(@NonNull XMLEvent event) {
<span class="fc" id="L203">    QName retval = null;</span>
<span class="fc bfc" id="L204" title="All 2 branches covered.">    if (event.isStartElement()) {</span>
<span class="fc" id="L205">      StartElement start = event.asStartElement();</span>
<span class="fc" id="L206">      retval = start.getName();</span>
<span class="fc bfc" id="L207" title="All 2 branches covered.">    } else if (event.isEndElement()) {</span>
<span class="fc" id="L208">      EndElement end = event.asEndElement();</span>
<span class="fc" id="L209">      retval = end.getName();</span>
    }
<span class="fc" id="L211">    return retval;</span>
  }

  /**
   * Get the event name of the {@code event}.
   *
   * @param event
   *          the XML event to get the event name for
   * @return the event name
   */
  @NonNull
  public static String toEventName(@NonNull XMLEvent event) {
<span class="fc" id="L223">    return toEventName(event.getEventType());</span>
  }

  /**
   * Get the event name of the {@code eventType}, which is one of the types
   * defined by {@link XMLStreamConstants}.
   *
   * @param eventType
   *          the event constant to get the event name for as defined by
   *          {@link XMLStreamConstants}
   * @return the event name
   */
  @NonNull
  public static String toEventName(int eventType) {
<span class="fc" id="L237">    String retval = EVENT_NAME_MAP.get(eventType);</span>
<span class="pc bpc" id="L238" title="1 of 2 branches missed.">    if (retval == null) {</span>
<span class="nc" id="L239">      retval = &quot;unknown event '&quot; + Integer.toString(eventType) + &quot;'&quot;;</span>
    }
<span class="fc" id="L241">    return retval;</span>
  }

  /**
   * Advance through XMLEvents until the event type identified by
   * {@code eventType} is reached or the end of stream is found.
   *
   * @param reader
   *          the XML event reader to advance
   * @param eventType
   *          the event type to stop on as defined by {@link XMLStreamConstants}
   * @return the next event of the specified type or {@code null} if the end of
   *         stream is reached
   * @throws XMLStreamException
   *           if an error occurred while advancing the stream
   */
  @Nullable
  public static XMLEvent advanceTo(@NonNull XMLEventReader2 reader, int eventType)
      throws XMLStreamException { // NO_UCD (unused code)
    XMLEvent xmlEvent;
    do {
<span class="nc" id="L262">      xmlEvent = reader.nextEvent();</span>
      // if (LOGGER.isWarnEnabled()) {
      // LOGGER.warn(&quot;skipping over: {}&quot;, XmlEventUtil.toString(xmlEvent));
      // }
<span class="nc bnc" id="L266" title="All 2 branches missed.">      if (xmlEvent.isStartElement()) {</span>
<span class="nc" id="L267">        advanceTo(reader, XMLStreamConstants.END_ELEMENT);</span>
        // skip this end element
<span class="nc" id="L269">        xmlEvent = reader.nextEvent();</span>
        // if (LOGGER.isDebugEnabled()) {
        // LOGGER.debug(&quot;skipping over: {}&quot;, XmlEventUtil.toString(xmlEvent));
        // }
      }
<span class="nc bnc" id="L274" title="All 4 branches missed.">    } while (reader.hasNext() &amp;&amp; (xmlEvent = reader.peek()).getEventType() != eventType);</span>
<span class="nc" id="L275">    return xmlEvent;</span>
  }

  /**
   * Skip over the next element in the event stream.
   *
   * @param reader
   *          the XML event stream reader
   * @return the next XML event
   * @throws XMLStreamException
   *           if an error occurred while reading the event stream
   */
  @SuppressWarnings(&quot;PMD.OnlyOneReturn&quot;)
  public static XMLEvent skipElement(@NonNull XMLEventReader2 reader) throws XMLStreamException {
<span class="nc" id="L289">    XMLEvent xmlEvent = reader.peek();</span>
<span class="nc bnc" id="L290" title="All 2 branches missed.">    if (!xmlEvent.isStartElement()) {</span>
<span class="nc" id="L291">      return xmlEvent;</span>
    }
    // if (LOGGER.isInfoEnabled()) {
    // LOGGER.atInfo().log(String.format(&quot;At location %s&quot;, toString(xmlEvent)));
    // }

<span class="nc" id="L297">    int depth = 0;</span>
    do {
<span class="nc" id="L299">      xmlEvent = reader.nextEvent();</span>
      // if (LOGGER.isInfoEnabled()) {
      // LOGGER.atInfo().log(String.format(&quot;Skipping %s&quot;, toString(xmlEvent)));
      // }
<span class="nc bnc" id="L303" title="All 2 branches missed.">      if (xmlEvent.isStartElement()) {</span>
<span class="nc" id="L304">        depth++;</span>
<span class="nc bnc" id="L305" title="All 2 branches missed.">      } else if (xmlEvent.isEndElement()) {</span>
<span class="nc" id="L306">        depth--;</span>
      }
<span class="nc bnc" id="L308" title="All 4 branches missed.">    } while (depth &gt; 0 &amp;&amp; reader.hasNext());</span>
<span class="nc" id="L309">    return reader.peek();</span>
  }

  /**
   * Skip over any processing instructions.
   *
   * @param reader
   *          the XML event reader to advance
   * @return the last processing instruction event or the reader's next event if
   *         no processing instruction was found
   * @throws XMLStreamException
   *           if an error occurred while advancing the stream
   */
  @NonNull
  public static XMLEvent skipProcessingInstructions(@NonNull XMLEventReader2 reader) throws XMLStreamException {
    XMLEvent nextEvent;
<span class="nc bnc" id="L325" title="All 2 branches missed.">    while ((nextEvent = reader.peek()).isProcessingInstruction()) {</span>
<span class="nc" id="L326">      nextEvent = reader.nextEvent();</span>
    }
<span class="nc" id="L328">    return nextEvent;</span>
  }

  /**
   * Skip over any whitespace.
   *
   * @param reader
   *          the XML event reader to advance
   * @return the last character event containing whitespace or the reader's next
   *         event if no character event was found
   * @throws XMLStreamException
   *           if an error occurred while advancing the stream
   */
  @SuppressWarnings(&quot;null&quot;)
  @NonNull
  public static XMLEvent skipWhitespace(@NonNull XMLEventReader2 reader) throws XMLStreamException {
    @NonNull XMLEvent nextEvent;
<span class="fc bfc" id="L345" title="All 2 branches covered.">    while ((nextEvent = reader.peek()).isCharacters()) {</span>
<span class="fc" id="L346">      Characters characters = nextEvent.asCharacters();</span>
<span class="fc" id="L347">      String data = characters.getData();</span>
<span class="pc bpc" id="L348" title="1 of 2 branches missed.">      if (WHITESPACE_ONLY.matcher(data).matches()) {</span>
<span class="fc" id="L349">        nextEvent = reader.nextEvent();</span>
      } else {
        break;
      }
<span class="fc" id="L353">    }</span>
<span class="fc" id="L354">    return nextEvent;</span>
  }

  /**
   * Determine if the {@code event} is an end element whose name matches the
   * provided {@code expectedQName}.
   *
   * @param event
   *          the XML event
   * @param expectedQName
   *          the expected element name
   * @return {@code true} if the next event matches the {@code expectedQName}
   */
  public static boolean isEventEndElement(XMLEvent event, @NonNull QName expectedQName) {
<span class="pc bpc" id="L368" title="1 of 2 branches missed.">    return event != null</span>
<span class="pc bpc" id="L369" title="1 of 2 branches missed.">        &amp;&amp; event.isEndElement()</span>
<span class="pc bpc" id="L370" title="1 of 2 branches missed.">        &amp;&amp; expectedQName.equals(event.asEndElement().getName());</span>
  }

  /**
   * Determine if the {@code event} is an end of document event.
   *
   * @param event
   *          the XML event
   * @return {@code true} if the next event is an end of document event
   */
  public static boolean isEventEndDocument(XMLEvent event) {
<span class="nc bnc" id="L381" title="All 2 branches missed.">    return event != null</span>
<span class="nc bnc" id="L382" title="All 2 branches missed.">        &amp;&amp; event.isEndElement();</span>
  }

  /**
   * Determine if the {@code event} is a start element whose name matches the
   * provided {@code expectedQName}.
   *
   * @param event
   *          the event
   * @param expectedQName
   *          the expected element name
   * @return {@code true} if the next event is a start element that matches the
   *         {@code expectedQName}
   * @throws XMLStreamException
   *           if an error occurred while looking at the next event
   */
  public static boolean isEventStartElement(XMLEvent event, @NonNull QName expectedQName) throws XMLStreamException {
<span class="nc bnc" id="L399" title="All 2 branches missed.">    return event != null</span>
<span class="nc bnc" id="L400" title="All 2 branches missed.">        &amp;&amp; event.isStartElement()</span>
<span class="nc bnc" id="L401" title="All 2 branches missed.">        &amp;&amp; expectedQName.equals(event.asStartElement().getName());</span>
  }

  /**
   * Consume the next event from {@code reader} and assert that this event is of
   * the type identified by {@code presumedEventType}.
   *
   * @param reader
   *          the XML event reader
   * @param presumedEventType
   *          the expected event type as defined by {@link XMLStreamConstants}
   * @return the next event
   * @throws XMLStreamException
   *           if an error occurred while looking at the next event
   */
  public static XMLEvent consumeAndAssert(XMLEventReader2 reader, int presumedEventType)
      throws XMLStreamException {
<span class="nc" id="L418">    return consumeAndAssert(reader, presumedEventType, null);</span>
  }

  /**
   * Consume the next event from {@code reader} and assert that this event is of
   * the type identified by {@code presumedEventType} and has the name identified
   * by {@code presumedName}.
   *
   * @param reader
   *          the XML event reader
   * @param presumedEventType
   *          the expected event type as defined by {@link XMLStreamConstants}
   * @param presumedName
   *          the expected name of the node associated with the event
   * @return the next event
   * @throws XMLStreamException
   *           if an error occurred while looking at the next event
   */
  public static XMLEvent consumeAndAssert(XMLEventReader2 reader, int presumedEventType, QName presumedName)
      throws XMLStreamException {
<span class="nc" id="L438">    XMLEvent retval = reader.nextEvent();</span>

<span class="nc" id="L440">    int eventType = retval.getEventType();</span>
<span class="nc" id="L441">    QName name = toQName(retval);</span>
<span class="nc bnc" id="L442" title="All 4 branches missed.">    assert eventType == presumedEventType</span>
        &amp;&amp; (presumedName == null
<span class="nc bnc" id="L444" title="All 2 branches missed.">            || presumedName.equals(name)) : generateExpectedMessage(</span>
                retval,
                presumedEventType,
                presumedName);
<span class="nc" id="L448">    return retval;</span>
  }

  /**
   * Ensure that the next event is an XML start element that matches the presumed
   * name.
   *
   * @param reader
   *          the XML event reader
   * @param presumedName
   *          the qualified name of the expected next event
   * @return the XML start element event
   * @throws IOException
   *           if an error occurred while parsing the resource
   * @throws XMLStreamException
   *           if an error occurred while parsing the XML event stream
   */
  @NonNull
  public static StartElement requireStartElement(
      @NonNull XMLEventReader2 reader,
      @NonNull QName presumedName) throws IOException, XMLStreamException {
<span class="nc" id="L469">    XMLEvent retval = reader.nextEvent();</span>
<span class="nc bnc" id="L470" title="All 4 branches missed.">    if (!(retval.isStartElement() &amp;&amp; presumedName.equals(retval.asStartElement().getName()))) {</span>
<span class="nc" id="L471">      throw new IOException(generateExpectedMessage(</span>
          retval,
          XMLStreamConstants.START_ELEMENT,
<span class="nc" id="L474">          presumedName).toString());</span>
    }
<span class="nc" id="L476">    return ObjectUtils.notNull(retval.asStartElement());</span>
  }

  /**
   * Ensure that the next event is an XML start element that matches the presumed
   * name.
   *
   * @param reader
   *          the XML event reader
   * @param presumedName
   *          the qualified name of the expected next event
   * @return the XML start element event
   * @throws IOException
   *           if an error occurred while parsing the resource
   * @throws XMLStreamException
   *           if an error occurred while parsing the XML event stream
   */
  @NonNull
  public static EndElement requireEndElement(
      @NonNull XMLEventReader2 reader,
      @NonNull QName presumedName) throws IOException, XMLStreamException {
<span class="nc" id="L497">    XMLEvent retval = reader.nextEvent();</span>
<span class="nc bnc" id="L498" title="All 4 branches missed.">    if (!(retval.isEndElement() &amp;&amp; presumedName.equals(retval.asEndElement().getName()))) {</span>
<span class="nc" id="L499">      throw new IOException(generateExpectedMessage(</span>
          retval,
          XMLStreamConstants.END_ELEMENT,
<span class="nc" id="L502">          presumedName).toString());</span>
    }
<span class="nc" id="L504">    return ObjectUtils.notNull(retval.asEndElement());</span>
  }

  /**
   * Ensure that the next event from {@code reader} is of the type identified by
   * {@code presumedEventType}.
   *
   * @param reader
   *          the event reader
   * @param presumedEventType
   *          the expected event type as defined by {@link XMLStreamConstants}
   * @return the next event
   * @throws XMLStreamException
   *           if an error occurred while looking at the next event
   * @throws AssertionError
   *           if the next event does not match the presumed event
   */
  public static XMLEvent assertNext(
      @NonNull XMLEventReader2 reader,
      int presumedEventType)
      throws XMLStreamException {
<span class="nc" id="L525">    return assertNext(reader, presumedEventType, null);</span>
  }

  /**
   * Ensure that the next event from {@code reader} is of the type identified by
   * {@code presumedEventType} and has the name identified by
   * {@code presumedName}.
   *
   * @param reader
   *          the event reader
   * @param presumedEventType
   *          the expected event type as defined by {@link XMLStreamConstants}
   * @param presumedName
   *          the expected name of the node associated with the event
   * @return the next event
   * @throws XMLStreamException
   *           if an error occurred while looking at the next event
   * @throws AssertionError
   *           if the next event does not match the presumed event
   */
  public static XMLEvent assertNext(
      @NonNull XMLEventReader2 reader,
      int presumedEventType,
      @Nullable QName presumedName)
      throws XMLStreamException {
<span class="fc" id="L550">    XMLEvent nextEvent = reader.peek();</span>

<span class="fc" id="L552">    int eventType = nextEvent.getEventType();</span>
<span class="pc bpc" id="L553" title="2 of 4 branches missed.">    assert eventType == presumedEventType</span>
        &amp;&amp; (presumedName == null
<span class="pc bpc" id="L555" title="1 of 2 branches missed.">            || presumedName.equals(toQName(nextEvent))) : generateExpectedMessage(</span>
                nextEvent,
                presumedEventType,
                presumedName);
<span class="fc" id="L559">    return nextEvent;</span>
  }

  /**
   * Generate a location string for the current location in the XML event stream.
   *
   * @param event
   *          an XML event
   * @return the location string
   */
  public static CharSequence generateLocationMessage(@NonNull XMLEvent event) {
<span class="nc" id="L570">    Location location = toLocation(event);</span>
<span class="nc bnc" id="L571" title="All 2 branches missed.">    return location == null ? &quot;&quot; : generateLocationMessage(location);</span>
  }

  /**
   * Generate a location string for the current location in the XML event stream.
   *
   * @param location
   *          an XML event stream location
   * @return the location string
   */
  public static CharSequence generateLocationMessage(@NonNull Location location) {
<span class="nc" id="L582">    return new StringBuilder(12)</span>
<span class="nc" id="L583">        .append(&quot; at &quot;)</span>
<span class="nc" id="L584">        .append(XmlEventUtil.toString(location));</span>
  }

  /**
   * Generate a message intended for error reporting based on a presumed event.
   *
   * @param event
   *          the current XML event
   * @param presumedEventType
   *          the expected event type ({@link XMLEvent#getEventType()})
   * @param presumedName
   *          the expected event qualified name or {@code null} if there is no
   *          expectation
   * @return the message string
   */
  public static CharSequence generateExpectedMessage(
      @Nullable XMLEvent event,
      int presumedEventType,
      @Nullable QName presumedName) {
<span class="nc" id="L603">    StringBuilder builder = new StringBuilder(64);</span>
<span class="nc" id="L604">    builder</span>
<span class="nc" id="L605">        .append(&quot;Expected XML &quot;)</span>
<span class="nc" id="L606">        .append(toEventName(presumedEventType));</span>

<span class="nc bnc" id="L608" title="All 2 branches missed.">    if (presumedName != null) {</span>
<span class="nc" id="L609">      builder.append(&quot; for QName '&quot;)</span>
<span class="nc" id="L610">          .append(presumedName.toString());</span>
    }

<span class="nc bnc" id="L613" title="All 2 branches missed.">    if (event == null) {</span>
<span class="nc" id="L614">      builder.append(&quot;', instead found null event&quot;);</span>
    } else {
<span class="nc" id="L616">      builder.append(&quot;', instead found &quot;)</span>
<span class="nc" id="L617">          .append(toString(event))</span>
<span class="nc" id="L618">          .append(generateLocationMessage(event));</span>
    }
<span class="nc" id="L620">    return builder;</span>
  }

  /**
   * Skips events specified by {@code events}.
   *
   * @param reader
   *          the event reader
   * @param events
   *          the events to skip
   * @return the next non-mataching event returned by
   *         {@link XMLEventReader2#peek()}, or {@code null} if there was no next
   *         event
   * @throws XMLStreamException
   *           if an error occurred while reading
   */
  public static XMLEvent skipEvents(XMLEventReader2 reader, int... events) throws XMLStreamException {
<span class="nc" id="L637">    Set&lt;Integer&gt; skipEvents = IntStream.of(events).boxed().collect(Collectors.toSet());</span>

<span class="nc" id="L639">    XMLEvent nextEvent = null;</span>
<span class="nc bnc" id="L640" title="All 2 branches missed.">    while (reader.hasNext()) {</span>
<span class="nc" id="L641">      nextEvent = reader.peek();</span>
<span class="nc bnc" id="L642" title="All 2 branches missed.">      if (!skipEvents.contains(nextEvent.getEventType())) {</span>
<span class="nc" id="L643">        break;</span>
      }
<span class="nc" id="L645">      reader.nextEvent();</span>
    }
<span class="nc" id="L647">    return nextEvent;</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>