<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>StaticContext.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Metaschema Core API</a> &gt; <a href="index.source.html" class="el_package">gov.nist.secauto.metaschema.core.metapath</a> &gt; <span class="el_source">StaticContext.java</span></div><h1>StaticContext.java</h1><pre class="source lang-java linenums">/*
 * SPDX-FileCopyrightText: none
 * SPDX-License-Identifier: CC0-1.0
 */

package gov.nist.secauto.metaschema.core.metapath;

import gov.nist.secauto.metaschema.core.metapath.EQNameUtils.IEQNamePrefixResolver;
import gov.nist.secauto.metaschema.core.util.CollectionUtil;
import gov.nist.secauto.metaschema.core.util.ObjectUtils;

import java.net.URI;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.stream.Collectors;

import javax.xml.XMLConstants;

import edu.umd.cs.findbugs.annotations.NonNull;
import edu.umd.cs.findbugs.annotations.Nullable;
import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;

// add support for default namespace
/**
 * The implementation of a Metapath
 * &lt;a href=&quot;https://www.w3.org/TR/xpath-31/#static_context&quot;&gt;static context&lt;/a&gt;.
 */
public final class StaticContext {
  @NonNull
  private static final Map&lt;String, URI&gt; WELL_KNOWN_NAMESPACES;
  @NonNull
  private static final Map&lt;String, String&gt; WELL_KNOWN_URI_TO_PREFIX;

  static {
<span class="fc" id="L35">    Map&lt;String, URI&gt; knownNamespaces = new ConcurrentHashMap&lt;&gt;();</span>
<span class="fc" id="L36">    knownNamespaces.put(</span>
        MetapathConstants.PREFIX_METAPATH,
        MetapathConstants.NS_METAPATH);
<span class="fc" id="L39">    knownNamespaces.put(</span>
        MetapathConstants.PREFIX_XML_SCHEMA,
        MetapathConstants.NS_XML_SCHEMA);
<span class="fc" id="L42">    knownNamespaces.put(</span>
        MetapathConstants.PREFIX_XPATH_FUNCTIONS,
        MetapathConstants.NS_METAPATH_FUNCTIONS);
<span class="fc" id="L45">    knownNamespaces.put(</span>
        MetapathConstants.PREFIX_XPATH_FUNCTIONS_MATH,
        MetapathConstants.NS_METAPATH_FUNCTIONS_MATH);
<span class="fc" id="L48">    knownNamespaces.put(</span>
        MetapathConstants.PREFIX_XPATH_FUNCTIONS_ARRAY,
        MetapathConstants.NS_METAPATH_FUNCTIONS_ARRAY);
<span class="fc" id="L51">    knownNamespaces.put(</span>
        MetapathConstants.PREFIX_XPATH_FUNCTIONS_MAP,
        MetapathConstants.NS_METAPATH_FUNCTIONS_MAP);
<span class="fc" id="L54">    WELL_KNOWN_NAMESPACES = CollectionUtil.unmodifiableMap(knownNamespaces);</span>

<span class="fc" id="L56">    WELL_KNOWN_URI_TO_PREFIX = ObjectUtils.notNull(WELL_KNOWN_NAMESPACES.entrySet().stream()</span>
<span class="fc" id="L57">        .collect(Collectors.toUnmodifiableMap(</span>
<span class="fc" id="L58">            entry -&gt; entry.getValue().toASCIIString(),</span>
            Map.Entry::getKey,
<span class="nc" id="L60">            (v1, v2) -&gt; v2)));</span>
<span class="fc" id="L61">  }</span>

  @Nullable
  private final URI baseUri;
  @NonNull
  private final Map&lt;String, URI&gt; knownNamespaces;
  @Nullable
  private final URI defaultModelNamespace;
  @Nullable
  private final URI defaultFunctionNamespace;
  private final boolean useWildcardWhenNamespaceNotDefaulted;

  /**
   * Get the mapping of prefix to namespace URI for all well-known namespaces
   * provided by default to the static context.
   * &lt;p&gt;
   * These namespaces can be overridden using the
   * {@link Builder#namespace(String, URI)} method.
   *
   * @return the mapping of prefix to namespace URI for all well-known namespaces
   */
  @SuppressFBWarnings(&quot;MS_EXPOSE_REP&quot;)
  public static Map&lt;String, URI&gt; getWellKnownNamespacesMap() {
<span class="nc" id="L84">    return WELL_KNOWN_NAMESPACES;</span>
  }

  /**
   * Get the mapping of namespace URIs to prefixes for all well-known namespaces
   * provided by default to the static context.
   *
   * @return the mapping of namespace URI to prefix for all well-known namespaces
   */
  @SuppressFBWarnings(&quot;MS_EXPOSE_REP&quot;)
  public static Map&lt;String, String&gt; getWellKnownURIToPrefixMap() {
<span class="nc" id="L95">    return WELL_KNOWN_URI_TO_PREFIX;</span>
  }

  /**
   * Get the namespace prefix associated with the provided URI, if the URI is
   * well-known.
   *
   * @param uri
   *          the URI to get the prefix for
   * @return the prefix or {@code null} if the provided URI is not well-known
   */
  @Nullable
  public static String getWellKnownPrefixForUri(@NonNull String uri) {
<span class="fc" id="L108">    return WELL_KNOWN_URI_TO_PREFIX.get(uri);</span>
  }

  /**
   * Create a new static context instance using default values.
   *
   * @return a new static context instance
   */
  @NonNull
  public static StaticContext instance() {
<span class="fc" id="L118">    return builder().build();</span>
  }

<span class="fc" id="L121">  private StaticContext(Builder builder) {</span>
<span class="fc" id="L122">    this.baseUri = builder.baseUri;</span>
<span class="fc" id="L123">    this.knownNamespaces = CollectionUtil.unmodifiableMap(ObjectUtils.notNull(Map.copyOf(builder.namespaces)));</span>
<span class="fc" id="L124">    this.defaultModelNamespace = builder.defaultModelNamespace;</span>
<span class="fc" id="L125">    this.defaultFunctionNamespace = builder.defaultFunctionNamespace;</span>
<span class="fc" id="L126">    this.useWildcardWhenNamespaceNotDefaulted = builder.useWildcardWhenNamespaceNotDefaulted;</span>
<span class="fc" id="L127">  }</span>

  /**
   * Get the static base URI to use in resolving URIs handled by the Metapath
   * processor. This URI, if provided, will be used when a document base URI is
   * not available.
   *
   * @return the base URI or {@code null} if not defined
   */
  @Nullable
  public URI getBaseUri() {
<span class="fc" id="L138">    synchronized (this) {</span>
<span class="fc" id="L139">      return baseUri;</span>
    }
  }

  /**
   * Get the namespace URI associated with the provided {@code prefix}, if any is
   * bound.
   * &lt;p&gt;
   * This method uses the namespaces set by the
   * {@link Builder#namespace(String, URI)} method, falling back to the well-known
   * namespace bindings when a prefix match is not found.
   * &lt;p&gt;
   * The well-known namespace bindings can be retrieved using the
   * {@link StaticContext#getWellKnownNamespacesMap()} method.
   *
   * @param prefix
   *          the namespace prefix
   * @return the namespace URI bound to the prefix, or {@code null} if no
   *         namespace is bound to the prefix
   * @see Builder#namespace(String, URI)
   * @see #getWellKnownNamespacesMap()
   */
  @Nullable
  public URI lookupNamespaceURIForPrefix(@NonNull String prefix) {
<span class="fc" id="L163">    URI retval = knownNamespaces.get(prefix);</span>
<span class="fc bfc" id="L164" title="All 2 branches covered.">    if (retval == null) {</span>
      // fall back to well-known namespaces
<span class="fc" id="L166">      retval = WELL_KNOWN_NAMESPACES.get(prefix);</span>
    }
<span class="fc" id="L168">    return retval;</span>
  }

  /**
   * Get the namespace associated with the provided {@code prefix} as a string, if
   * any is bound.
   *
   * @param prefix
   *          the namespace prefix
   * @return the namespace string bound to the prefix, or {@code null} if no
   *         namespace is bound to the prefix
   */
  @Nullable
  public String lookupNamespaceForPrefix(@NonNull String prefix) {
<span class="fc" id="L182">    URI result = lookupNamespaceURIForPrefix(prefix);</span>
<span class="fc bfc" id="L183" title="All 2 branches covered.">    return result == null ? null : result.toASCIIString();</span>
  }

  /**
   * Get the default namespace for assembly, field, or flag references that have
   * no namespace prefix.
   *
   * @return the namespace if defined or {@code null} otherwise
   */
  @Nullable
  public URI getDefaultModelNamespace() {
<span class="fc" id="L194">    return defaultModelNamespace;</span>
  }

  /**
   * Get the default namespace for function references that have no namespace
   * prefix.
   *
   * @return the namespace if defined or {@code null} otherwise
   */
  @Nullable
  public URI getDefaultFunctionNamespace() {
<span class="fc" id="L205">    return defaultFunctionNamespace;</span>
  }

  /**
   * Get a prefix resolver for use with Metapath function names that will attempt
   * to identify the namespace corresponding to a given prefix.
   * &lt;p&gt;
   * This will use the following lookup order, advancing to the next when a
   * {@code null} value is returned:
   * &lt;ol&gt;
   * &lt;li&gt;Lookup the prefix using
   * {@link StaticContext#lookupNamespaceForPrefix(String)}&lt;/li&gt;
   * &lt;li&gt;Return the result of
   * {@link StaticContext#getDefaultFunctionNamespace()}&lt;/li&gt;
   * &lt;li&gt;Return {@link XMLConstants#NULL_NS_URI}&lt;/li&gt;
   * &lt;/ol&gt;
   *
   * @return the resolver
   */
  @NonNull
  public IEQNamePrefixResolver getFunctionPrefixResolver() {
<span class="fc" id="L226">    return this::resolveFunctionPrefix;</span>
  }

  @NonNull
  private String resolveFunctionPrefix(@NonNull String prefix) {
<span class="fc" id="L231">    String ns = lookupNamespaceForPrefix(prefix);</span>
<span class="fc bfc" id="L232" title="All 2 branches covered.">    if (ns == null) {</span>
<span class="fc" id="L233">      URI uri = getDefaultFunctionNamespace();</span>
<span class="pc bpc" id="L234" title="1 of 2 branches missed.">      if (uri != null) {</span>
<span class="fc" id="L235">        ns = uri.toASCIIString();</span>
      }
    }
<span class="pc bpc" id="L238" title="1 of 2 branches missed.">    return ns == null ? XMLConstants.NULL_NS_URI : ns;</span>
  }

  /**
   * Get a prefix resolver for use with Metapath flag node names that will attempt
   * to identify the namespace corresponding to a given prefix.
   * &lt;p&gt;
   * This will use the following lookup order, advancing to the next when a
   * {@code null} value is returned:
   * &lt;ol&gt;
   * &lt;li&gt;Lookup the prefix using
   * {@link StaticContext#lookupNamespaceForPrefix(String)}&lt;/li&gt;
   * &lt;li&gt;Return {@link XMLConstants#NULL_NS_URI}&lt;/li&gt;
   * &lt;/ol&gt;
   *
   * @return the resolver
   */
  @NonNull
  public IEQNamePrefixResolver getFlagPrefixResolver() {
<span class="fc" id="L257">    return this::resolveFlagReferencePrefix;</span>
  }

  @NonNull
  private String resolveFlagReferencePrefix(@NonNull String prefix) {
<span class="fc" id="L262">    String ns = lookupNamespaceForPrefix(prefix);</span>
<span class="fc bfc" id="L263" title="All 2 branches covered.">    return ns == null ? XMLConstants.NULL_NS_URI : ns;</span>
  }

  /**
   * Get a prefix resolver for use with Metapath model node names that will
   * attempt to identify the namespace corresponding to a given prefix.
   * &lt;p&gt;
   * This will use the following lookup order, advancing to the next when a
   * {@code null} value is returned:
   * &lt;ol&gt;
   * &lt;li&gt;Lookup the prefix using
   * {@link StaticContext#lookupNamespaceForPrefix(String)}&lt;/li&gt;
   * &lt;li&gt;Return the result of
   * {@link StaticContext#getDefaultModelNamespace()}&lt;/li&gt;
   * &lt;li&gt;Return {@link XMLConstants#NULL_NS_URI}&lt;/li&gt;
   * &lt;/ol&gt;
   *
   * @return the resolver
   */
  @NonNull
  public IEQNamePrefixResolver getModelPrefixResolver() {
<span class="fc" id="L284">    return this::resolveModelReferencePrefix;</span>
  }

  @NonNull
  private String resolveModelReferencePrefix(@NonNull String prefix) {
<span class="fc" id="L289">    String ns = lookupNamespaceForPrefix(prefix);</span>
<span class="fc bfc" id="L290" title="All 2 branches covered.">    if (ns == null) {</span>
<span class="fc" id="L291">      URI uri = getDefaultModelNamespace();</span>
<span class="fc bfc" id="L292" title="All 2 branches covered.">      if (uri != null) {</span>
<span class="fc" id="L293">        ns = uri.toASCIIString();</span>
      }
    }
<span class="fc bfc" id="L296" title="All 2 branches covered.">    return ns == null ? XMLConstants.NULL_NS_URI : ns;</span>
  }

  /**
   * Get a prefix resolver for use with Metapath variable names that will attempt
   * to identify the namespace corresponding to a given prefix.
   * &lt;p&gt;
   * This will use the following lookup order, advancing to the next when a
   * {@code null} value is returned:
   * &lt;ol&gt;
   * &lt;li&gt;Lookup the prefix using
   * {@link StaticContext#lookupNamespaceForPrefix(String)}&lt;/li&gt;
   * &lt;li&gt;Return {@link XMLConstants#NULL_NS_URI}&lt;/li&gt;
   * &lt;/ol&gt;
   *
   * @return the resolver
   */
  @NonNull
  public IEQNamePrefixResolver getVariablePrefixResolver() {
<span class="fc" id="L315">    return this::resolveVariablePrefix;</span>
  }

  @NonNull
  private String resolveVariablePrefix(@NonNull String prefix) {
<span class="fc" id="L320">    String ns = lookupNamespaceForPrefix(prefix);</span>
<span class="fc bfc" id="L321" title="All 2 branches covered.">    return ns == null ? XMLConstants.NULL_NS_URI : ns;</span>
  }

  /**
   * Get a new static context builder that is pre-populated with the setting of
   * this static context.
   *
   * @return a new builder
   */
  @NonNull
  public Builder buildFrom() {
<span class="nc" id="L332">    Builder builder = builder();</span>
<span class="nc" id="L333">    builder.baseUri = this.baseUri;</span>
<span class="nc" id="L334">    builder.namespaces.putAll(this.knownNamespaces);</span>
<span class="nc" id="L335">    builder.defaultModelNamespace = this.defaultModelNamespace;</span>
<span class="nc" id="L336">    builder.defaultFunctionNamespace = this.defaultFunctionNamespace;</span>
<span class="nc" id="L337">    return builder;</span>
  }

  /**
   * Indicates if a name match should use a wildcard for the namespace is the
   * namespace does not have a value and the {@link #getDefaultModelNamespace()}
   * is {@code null}.
   *
   * @return {@code true} if a wildcard match on the name space should be used or
   *         {@code false} otherwise
   */
  public boolean isUseWildcardWhenNamespaceNotDefaulted() {
<span class="pc bpc" id="L349" title="3 of 4 branches missed.">    return useWildcardWhenNamespaceNotDefaulted &amp;&amp; getDefaultModelNamespace() == null;</span>
  }

  /**
   * Create a new static context builder that allows for fine-grained adjustments
   * when creating a new static context.
   *
   * @return a new builder
   */
  @NonNull
  public static Builder builder() {
<span class="fc" id="L360">    return new Builder();</span>
  }

  /**
   * A builder used to generate the static context.
   */
  public static final class Builder {
    public boolean useWildcardWhenNamespaceNotDefaulted; // false
    @Nullable
    private URI baseUri;
<span class="fc" id="L370">    @NonNull</span>
    private final Map&lt;String, URI&gt; namespaces = new ConcurrentHashMap&lt;&gt;();
    @Nullable
    private URI defaultModelNamespace;
<span class="fc" id="L374">    @Nullable</span>
    private URI defaultFunctionNamespace = MetapathConstants.NS_METAPATH_FUNCTIONS;

<span class="fc" id="L377">    private Builder() {</span>
<span class="fc" id="L378">      namespaces.put(</span>
          MetapathConstants.PREFIX_METAPATH,
          MetapathConstants.NS_METAPATH);
<span class="fc" id="L381">      namespaces.put(</span>
          MetapathConstants.PREFIX_XML_SCHEMA,
          MetapathConstants.NS_XML_SCHEMA);
<span class="fc" id="L384">      namespaces.put(</span>
          MetapathConstants.PREFIX_XPATH_FUNCTIONS,
          MetapathConstants.NS_METAPATH_FUNCTIONS);
<span class="fc" id="L387">      namespaces.put(</span>
          MetapathConstants.PREFIX_XPATH_FUNCTIONS_MATH,
          MetapathConstants.NS_METAPATH_FUNCTIONS_MATH);
<span class="fc" id="L390">    }</span>

    /**
     * Sets the static base URI to use in resolving URIs handled by the Metapath
     * processor, when a document base URI is not available. There is only a single
     * base URI. Subsequent calls to this method will change the base URI.
     *
     * @param uri
     *          the base URI to use
     * @return this builder
     */
    @NonNull
    public Builder baseUri(@NonNull URI uri) {
<span class="fc" id="L403">      this.baseUri = uri;</span>
<span class="fc" id="L404">      return this;</span>
    }

    /**
     * Adds a new prefix to namespace URI binding to the mapping of
     * &lt;a href=&quot;https://www.w3.org/TR/xpath-31/#dt-static-namespaces&quot;&gt;statically
     * known namespaces&lt;/a&gt;.
     * &lt;p&gt;
     * A namespace set by this method can be resolved using the
     * {@link StaticContext#lookupNamespaceForPrefix(String)} method.
     * &lt;p&gt;
     * Well-known namespace bindings are used by default, which can be retrieved
     * using the {@link StaticContext#getWellKnownNamespacesMap()} method.
     *
     * @param prefix
     *          the prefix to associate with the namespace, which may be
     * @param uri
     *          the namespace URI
     * @return this builder
     * @see StaticContext#lookupNamespaceForPrefix(String)
     * @see StaticContext#lookupNamespaceURIForPrefix(String)
     * @see StaticContext#getWellKnownNamespacesMap()
     */
    @NonNull
    public Builder namespace(@NonNull String prefix, @NonNull URI uri) {
<span class="fc" id="L429">      this.namespaces.put(prefix, uri);</span>
<span class="fc" id="L430">      return this;</span>
    }

    /**
     * A convenience method for {@link #namespace(String, URI)}.
     *
     * @param prefix
     *          the prefix to associate with the namespace, which may be
     * @param uri
     *          the namespace URI
     * @return this builder
     * @throws IllegalArgumentException
     *           if the provided URI is invalid
     * @see StaticContext#lookupNamespaceForPrefix(String)
     * @see StaticContext#lookupNamespaceURIForPrefix(String)
     * @see StaticContext#getWellKnownNamespacesMap()
     */
    @NonNull
    public Builder namespace(@NonNull String prefix, @NonNull String uri) {
<span class="fc" id="L449">      return namespace(prefix, ObjectUtils.notNull(URI.create(uri)));</span>
    }

    /**
     * Defines the default namespace to use for assembly, field, or flag references
     * that have no namespace prefix.
     *
     * @param uri
     *          the namespace URI
     * @return this builder
     * @see StaticContext#getDefaultModelNamespace()
     */
    @NonNull
    public Builder defaultModelNamespace(@NonNull URI uri) {
<span class="fc" id="L463">      this.defaultModelNamespace = uri;</span>
<span class="fc" id="L464">      return this;</span>
    }

    /**
     * A convenience method for {@link #defaultModelNamespace(URI)}.
     *
     * @param uri
     *          the namespace URI
     * @return this builder
     * @throws IllegalArgumentException
     *           if the provided URI is invalid
     * @see StaticContext#getDefaultModelNamespace()
     */
    @NonNull
    public Builder defaultModelNamespace(@NonNull String uri) {
<span class="fc" id="L479">      return defaultModelNamespace(ObjectUtils.notNull(URI.create(uri)));</span>
    }

    /**
     * Defines the default namespace to use for assembly, field, or flag references
     * that have no namespace prefix.
     *
     * @param uri
     *          the namespace URI
     * @return this builder
     * @see StaticContext#getDefaultFunctionNamespace()
     */
    @NonNull
    public Builder defaultFunctionNamespace(@NonNull URI uri) {
<span class="fc" id="L493">      this.defaultFunctionNamespace = uri;</span>
<span class="fc" id="L494">      return this;</span>
    }

    /**
     * A convenience method for {@link #defaultFunctionNamespace(URI)}.
     *
     * @param uri
     *          the namespace URI
     * @return this builder
     * @throws IllegalArgumentException
     *           if the provided URI is invalid
     * @see StaticContext#getDefaultFunctionNamespace()
     */
    @NonNull
    public Builder defaultFunctionNamespace(@NonNull String uri) {
<span class="fc" id="L509">      return defaultFunctionNamespace(ObjectUtils.notNull(URI.create(uri)));</span>
    }

    /**
     * Set the name matching behavior for when a model node has no namespace.
     *
     * @param value
     *          {@code true} if on or {@code false} otherwise
     * @return this builder
     */
    public Builder useWildcardWhenNamespaceNotDefaulted(boolean value) {
<span class="fc" id="L520">      this.useWildcardWhenNamespaceNotDefaulted = value;</span>
<span class="fc" id="L521">      return this;</span>
    }

    /**
     * Construct a new static context using the information provided to the builder.
     *
     * @return the new static context
     */
    @NonNull
    public StaticContext build() {
<span class="fc" id="L531">      return new StaticContext(this);</span>
    }
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>