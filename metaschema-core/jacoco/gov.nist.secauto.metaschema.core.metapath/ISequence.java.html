<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ISequence.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Metaschema Core API</a> &gt; <a href="index.source.html" class="el_package">gov.nist.secauto.metaschema.core.metapath</a> &gt; <span class="el_source">ISequence.java</span></div><h1>ISequence.java</h1><pre class="source lang-java linenums">/*
 * SPDX-FileCopyrightText: none
 * SPDX-License-Identifier: CC0-1.0
 */

package gov.nist.secauto.metaschema.core.metapath;

import gov.nist.secauto.metaschema.core.metapath.impl.AbstractSequence;
import gov.nist.secauto.metaschema.core.metapath.impl.SequenceN;
import gov.nist.secauto.metaschema.core.metapath.impl.SingletonSequence;
import gov.nist.secauto.metaschema.core.metapath.impl.StreamSequence;
import gov.nist.secauto.metaschema.core.metapath.item.IItem;
import gov.nist.secauto.metaschema.core.metapath.item.function.IArrayItem;
import gov.nist.secauto.metaschema.core.util.ObjectUtils;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Iterator;
import java.util.List;
import java.util.Set;
import java.util.function.BiConsumer;
import java.util.function.BinaryOperator;
import java.util.function.Function;
import java.util.function.Supplier;
import java.util.stream.Collector;
import java.util.stream.Stream;

import edu.umd.cs.findbugs.annotations.NonNull;
import edu.umd.cs.findbugs.annotations.Nullable;

/**
 * Represents an ordered collection of Metapath expression results.
 * &lt;p&gt;
 * Items is a sequence are typically ordered based on their position in the
 * original node graph based on a depth first ordering.
 *
 * @param &lt;ITEM&gt;
 *          the Java type of the items in a sequence
 */
@SuppressWarnings(&quot;PMD.ShortMethodName&quot;)
public interface ISequence&lt;ITEM extends IItem&gt; extends List&lt;ITEM&gt;, IPrintable, ICollectionValue {
  /**
   * Get an empty sequence.
   *
   * @param &lt;T&gt;
   *          the item type
   * @return the empty sequence
   */
  @SuppressWarnings(&quot;null&quot;)
  @NonNull
  static &lt;T extends IItem&gt; ISequence&lt;T&gt; empty() {
<span class="fc" id="L53">    return AbstractSequence.empty();</span>
  }

  @Override
  default Iterator&lt;ITEM&gt; iterator() {
<span class="nc" id="L58">    return getValue().listIterator();</span>
  }

  /**
   * Get the items in this sequence as a {@link List}.
   *
   * @return a list containing all the items of the sequence
   */
  @NonNull
  List&lt;ITEM&gt; getValue();

  /**
   * Get the items in this sequence as a {@link Stream}.
   *
   * @return a stream containing all the items of the sequence
   */
  @Override
  @NonNull
  Stream&lt;ITEM&gt; stream();

  /**
   * Retrieves the first item in a sequence.
   * &lt;p&gt;
   * If the sequence is empty, a {@code null} result is returned. If
   * requireSingleton is {@code true} and the sequence contains more than one
   * item, a {@link TypeMetapathException} is thrown.
   *
   * @param &lt;T&gt;
   *          the item type to return derived from the provided sequence
   * @param items
   *          the sequence to retrieve the first item from
   * @param requireSingleton
   *          if {@code true} then a {@link TypeMetapathException} is thrown if
   *          the sequence contains more than one item
   * @return {@code null} if the sequence is empty, or the item otherwise
   * @throws TypeMetapathException
   *           if the sequence contains more than one item and requireSingleton is
   *           {@code true}
   */
  static &lt;T extends IItem&gt; T getFirstItem(@NonNull ISequence&lt;T&gt; items, boolean requireSingleton) {
<span class="fc" id="L98">    return getFirstItem(items.stream(), requireSingleton);</span>
  }

  /**
   * Retrieves the first item in a stream of items.
   * &lt;p&gt;
   * If the sequence is empty, a {@code null} result is returned. If
   * requireSingleton is {@code true} and the sequence contains more than one
   * item, a {@link TypeMetapathException} is thrown.
   *
   * @param &lt;T&gt;
   *          the item type to return derived from the provided sequence
   * @param items
   *          the sequence to retrieve the first item from
   * @param requireSingleton
   *          if {@code true} then a {@link TypeMetapathException} is thrown if
   *          the sequence contains more than one item
   * @return {@code null} if the sequence is empty, or the item otherwise
   * @throws TypeMetapathException
   *           if the sequence contains more than one item and requireSingleton is
   *           {@code true}
   */
  static &lt;T extends IItem&gt; T getFirstItem(@NonNull Stream&lt;T&gt; items, boolean requireSingleton) {
<span class="fc" id="L121">    return items.limit(2)</span>
<span class="fc" id="L122">        .reduce((t, u) -&gt; {</span>
<span class="fc bfc" id="L123" title="All 2 branches covered.">          if (requireSingleton) {</span>
<span class="fc" id="L124">            throw new InvalidTypeMetapathException(</span>
                null,
<span class="fc" id="L126">                String.format(&quot;sequence expected to contain only one item, but found multiple&quot;));</span>
          }
<span class="fc" id="L128">          return t;</span>
<span class="fc" id="L129">        }).orElse(null);</span>
  }

  /**
   * Retrieves the first item in this sequence.
   * &lt;p&gt;
   * If the sequence is empty, a {@code null} result is returned. If
   * requireSingleton is {@code true} and the sequence contains more than one
   * item, a {@link TypeMetapathException} is thrown.
   *
   * @param requireSingleton
   *          if {@code true} then a {@link TypeMetapathException} is thrown if
   *          the sequence contains more than one item
   * @return {@code null} if the sequence is empty, or the item otherwise
   * @throws TypeMetapathException
   *           if the sequence contains more than one item and requireSingleton is
   *           {@code true}
   */
  @Nullable
  default ITEM getFirstItem(boolean requireSingleton) {
<span class="fc" id="L149">    return getFirstItem(this, requireSingleton);</span>
  }

  /**
   * Get this sequence as a collection value.
   *
   * @return the collection value
   */
  @NonNull
  default ICollectionValue toCollectionValue() {
    ICollectionValue retval;
<span class="fc bfc" id="L160" title="All 3 branches covered.">    switch (size()) {</span>
    case 0:
<span class="fc" id="L162">      retval = empty();</span>
<span class="fc" id="L163">      break;</span>
    case 1:
      // get the singleton item
<span class="fc" id="L166">      retval = ObjectUtils.notNull(stream().findFirst().get());</span>
<span class="fc" id="L167">      break;</span>
    default:
      // get this sequence of 2 or more items
<span class="fc" id="L170">      retval = this;</span>
    }
<span class="fc" id="L172">    return retval;</span>
  }

  /**
   * Get a stream guaranteed to be backed by a list.
   *
   * @return the stream
   */
  @NonNull
  default Stream&lt;ITEM&gt; safeStream() {
<span class="fc" id="L182">    return ObjectUtils.notNull(getValue().stream());</span>
  }

  @SuppressWarnings(&quot;null&quot;)
  @Override
  default Stream&lt;? extends IItem&gt; flatten() {
    // TODO: Is a safe stream needed here?
<span class="nc" id="L189">    return safeStream();</span>
  }

  /**
   * A {@link Collector} implementation to generates a sequence from a stream of
   * Metapath items.
   *
   * @param &lt;ITEM_TYPE&gt;
   *          the Java type of the items
   * @return a collector that will generate a sequence
   */
  @NonNull
  static &lt;ITEM_TYPE extends IItem&gt; Collector&lt;ITEM_TYPE, ?, ISequence&lt;ITEM_TYPE&gt;&gt; toSequence() {
<span class="fc" id="L202">    return new Collector&lt;ITEM_TYPE, List&lt;ITEM_TYPE&gt;, ISequence&lt;ITEM_TYPE&gt;&gt;() {</span>

      @Override
      public Supplier&lt;List&lt;ITEM_TYPE&gt;&gt; supplier() {
<span class="fc" id="L206">        return ArrayList::new;</span>
      }

      @Override
      public BiConsumer&lt;List&lt;ITEM_TYPE&gt;, ITEM_TYPE&gt; accumulator() {
<span class="fc" id="L211">        return List::add;</span>
      }

      @Override
      public BinaryOperator&lt;List&lt;ITEM_TYPE&gt;&gt; combiner() {
<span class="fc" id="L216">        return (list1, list2) -&gt; {</span>
<span class="nc" id="L217">          list1.addAll(list2);</span>
<span class="nc" id="L218">          return list1;</span>
        };
      }

      @Override
      public Function&lt;List&lt;ITEM_TYPE&gt;, ISequence&lt;ITEM_TYPE&gt;&gt; finisher() {
<span class="fc" id="L224">        return list -&gt; ofCollection(ObjectUtils.notNull(list));</span>
      }

      @Override
      public Set&lt;Characteristics&gt; characteristics() {
<span class="fc" id="L229">        return Collections.emptySet();</span>
      }
    };
  }

  @Override
  default ISequence&lt;ITEM&gt; asSequence() {
<span class="fc" id="L236">    return this;</span>
  }

  /**
   * Apply the provided {@code mapFunction} to each item in the sequence.
   *
   * @param &lt;T&gt;
   *          the Java type of the provided items
   * @param &lt;R&gt;
   *          the Java type of the resulting items
   * @param mapFunction
   *          the map function to apply to each item in the provided sequence
   * @param seq
   *          the sequence of items to map
   * @return a new sequence containing the mapped items
   */
  static &lt;T extends R, R extends IItem&gt; ISequence&lt;R&gt; map(
      @NonNull Function&lt;T, R&gt; mapFunction,
      @NonNull ISequence&lt;T&gt; seq) {
<span class="nc" id="L255">    return seq.safeStream()</span>
<span class="nc" id="L256">        .map(mapFunction::apply)</span>
<span class="nc" id="L257">        .collect(toSequence());</span>
  }

  /**
   * Returns an unmodifiable sequence containing the provided {@code items}.
   *
   * @param &lt;ITEM_TYPE&gt;
   *          the type of items contained in the sequence.
   * @param items
   *          the items to add to the sequence
   * @return the new sequence
   */
  @NonNull
  static &lt;ITEM_TYPE extends IItem&gt; ISequence&lt;ITEM_TYPE&gt; ofCollection( // NOPMD - intentional
      @NonNull List&lt;ITEM_TYPE&gt; items) {
    ISequence&lt;ITEM_TYPE&gt; retval;
<span class="fc bfc" id="L273" title="All 2 branches covered.">    if (items.isEmpty()) {</span>
<span class="fc" id="L274">      retval = empty();</span>
<span class="fc bfc" id="L275" title="All 2 branches covered.">    } else if (items.size() == 1) {</span>
<span class="fc" id="L276">      retval = new SingletonSequence&lt;&gt;(ObjectUtils.notNull(items.iterator().next()));</span>
    } else {
<span class="fc" id="L278">      retval = new SequenceN&lt;&gt;(items);</span>
    }
<span class="fc" id="L280">    return retval;</span>
  }

  /**
   * Returns an unmodifiable sequence containing the provided {@code item}.
   * &lt;p&gt;
   * If the item is {@code null} and empty sequence will be created.
   *
   * @param &lt;T&gt;
   *          the type of items contained in the sequence.
   * @param item
   *          the item to add to the sequence
   * @return the new sequence
   */
  @NonNull
  static &lt;T extends IItem&gt; ISequence&lt;T&gt; of( // NOPMD - intentional
      @Nullable T item) {
<span class="fc bfc" id="L297" title="All 2 branches covered.">    return item == null ? empty() : new SingletonSequence&lt;&gt;(item);</span>
  }

  /**
   * Returns an unmodifiable sequence containing the provided {@code items}.
   *
   * @param &lt;T&gt;
   *          the type of items contained in the sequence.
   * @param items
   *          the items to add to the sequence
   * @return the new sequence
   */
  // TODO: remove null check on callers
  @NonNull
  static &lt;T extends IItem&gt; ISequence&lt;T&gt; of(@NonNull Stream&lt;T&gt; items) {
<span class="fc" id="L312">    return new StreamSequence&lt;&gt;(items);</span>
  }

  /**
   * Returns an unmodifiable sequence containing zero elements.
   *
   * @param &lt;T&gt;
   *          the item type
   * @return an empty {@code ISequence}
   */
  @NonNull
  static &lt;T extends IItem&gt; ISequence&lt;T&gt; of() {
<span class="fc" id="L324">    return empty();</span>
  }

  /**
   * Returns an unmodifiable sequence containing two items.
   *
   * @param &lt;T&gt;
   *          the {@code ISequence}'s item type
   * @param e1
   *          the first item
   * @param e2
   *          the second item
   * @return an {@code ISequence} containing the specified items
   * @throws NullPointerException
   *           if an item is {@code null}
   */
  @NonNull
  static &lt;T extends IItem&gt; ISequence&lt;T&gt; of(T e1, T e2) {
<span class="fc" id="L342">    return new SequenceN&lt;&gt;(e1, e2);</span>
  }

  /**
   * Returns an unmodifiable sequence containing three elements.
   *
   * @param &lt;T&gt;
   *          the {@code ISequence}'s item type
   * @param e1
   *          the first item
   * @param e2
   *          the second item
   * @param e3
   *          the third item
   * @return an {@code ISequence} containing the specified items
   * @throws NullPointerException
   *           if an item is {@code null}
   */
  @NonNull
  static &lt;T extends IItem&gt; ISequence&lt;T&gt; of(T e1, T e2, T e3) {
<span class="fc" id="L362">    return new SequenceN&lt;&gt;(e1, e2, e3);</span>
  }

  /**
   * Returns an unmodifiable sequence containing four items.
   *
   * @param &lt;T&gt;
   *          the {@code ISequence}'s item type
   * @param e1
   *          the first item
   * @param e2
   *          the second item
   * @param e3
   *          the third item
   * @param e4
   *          the fourth item
   * @return an {@code ISequence} containing the specified items
   * @throws NullPointerException
   *           if an item is {@code null}
   */
  @NonNull
  static &lt;T extends IItem&gt; ISequence&lt;T&gt; of(T e1, T e2, T e3, T e4) {
<span class="fc" id="L384">    return new SequenceN&lt;&gt;(e1, e2, e3, e4);</span>
  }

  /**
   * Returns an unmodifiable sequence containing five items.
   *
   * @param &lt;T&gt;
   *          the {@code ISequence}'s item type
   * @param e1
   *          the first item
   * @param e2
   *          the second item
   * @param e3
   *          the third item
   * @param e4
   *          the fourth item
   * @param e5
   *          the fifth item
   * @return an {@code ISequence} containing the specified items
   * @throws NullPointerException
   *           if an item is {@code null}
   */
  @NonNull
  static &lt;T extends IItem&gt; ISequence&lt;T&gt; of(T e1, T e2, T e3, T e4, T e5) {
<span class="nc" id="L408">    return new SequenceN&lt;&gt;(e1, e2, e3, e4, e5);</span>
  }

  /**
   * Returns an unmodifiable sequence containing six items.
   *
   * @param &lt;T&gt;
   *          the {@code ISequence}'s item type
   * @param e1
   *          the first item
   * @param e2
   *          the second item
   * @param e3
   *          the third item
   * @param e4
   *          the fourth item
   * @param e5
   *          the fifth item
   * @param e6
   *          the sixth item
   * @return an {@code ISequence} containing the specified items
   * @throws NullPointerException
   *           if an item is {@code null}
   */
  @NonNull
  static &lt;T extends IItem&gt; ISequence&lt;T&gt; of(T e1, T e2, T e3, T e4, T e5, T e6) {
<span class="nc" id="L434">    return new SequenceN&lt;&gt;(e1, e2, e3, e4, e5, e6);</span>
  }

  /**
   * Returns an unmodifiable sequence containing seven items.
   *
   * @param &lt;T&gt;
   *          the {@code ISequence}'s item type
   * @param e1
   *          the first item
   * @param e2
   *          the second item
   * @param e3
   *          the third item
   * @param e4
   *          the fourth item
   * @param e5
   *          the fifth item
   * @param e6
   *          the sixth item
   * @param e7
   *          the seventh item
   * @return an {@code ISequence} containing the specified items
   * @throws NullPointerException
   *           if an item is {@code null}
   */
  @NonNull
  static &lt;T extends IItem&gt; ISequence&lt;T&gt; of(T e1, T e2, T e3, T e4, T e5, T e6, T e7) {
<span class="nc" id="L462">    return new SequenceN&lt;&gt;(e1, e2, e3, e4, e5, e6, e7);</span>
  }

  /**
   * Returns an unmodifiable sequence containing eight items.
   *
   * @param &lt;T&gt;
   *          the {@code ISequence}'s item type
   * @param e1
   *          the first item
   * @param e2
   *          the second item
   * @param e3
   *          the third item
   * @param e4
   *          the fourth item
   * @param e5
   *          the fifth item
   * @param e6
   *          the sixth item
   * @param e7
   *          the seventh item
   * @param e8
   *          the eighth item
   * @return an {@code ISequence} containing the specified items
   * @throws NullPointerException
   *           if an item is {@code null}
   */
  @NonNull
  static &lt;T extends IItem&gt; ISequence&lt;T&gt; of(T e1, T e2, T e3, T e4, T e5, T e6, T e7, T e8) {
<span class="nc" id="L492">    return new SequenceN&lt;&gt;(e1, e2, e3, e4, e5, e6, e7, e8);</span>
  }

  /**
   * Returns an unmodifiable sequence containing nine items.
   *
   * @param &lt;T&gt;
   *          the {@code ISequence}'s item type
   * @param e1
   *          the first item
   * @param e2
   *          the second item
   * @param e3
   *          the third item
   * @param e4
   *          the fourth item
   * @param e5
   *          the fifth item
   * @param e6
   *          the sixth item
   * @param e7
   *          the seventh item
   * @param e8
   *          the eighth item
   * @param e9
   *          the ninth item
   * @return an {@code ISequence} containing the specified items
   * @throws NullPointerException
   *           if an item is {@code null}
   */
  @NonNull
  static &lt;T extends IItem&gt; ISequence&lt;T&gt; of(T e1, T e2, T e3, T e4, T e5, T e6, T e7, T e8, T e9) {
<span class="nc" id="L524">    return new SequenceN&lt;&gt;(e1, e2, e3, e4, e5, e6, e7, e8, e9);</span>
  }

  /**
   * Returns an unmodifiable sequence containing ten items.
   *
   * @param &lt;T&gt;
   *          the {@code ISequence}'s item type
   * @param e1
   *          the first item
   * @param e2
   *          the second item
   * @param e3
   *          the third item
   * @param e4
   *          the fourth item
   * @param e5
   *          the fifth item
   * @param e6
   *          the sixth item
   * @param e7
   *          the seventh item
   * @param e8
   *          the eighth item
   * @param e9
   *          the ninth item
   * @param e10
   *          the tenth item
   * @return an {@code IArrayItem} containing the specified items
   * @throws NullPointerException
   *           if an item is {@code null}
   */
  @NonNull
  static &lt;T extends IItem&gt; ISequence&lt;T&gt; of(T e1, T e2, T e3, T e4, T e5, T e6, T e7, T e8, T e9, T e10) {
<span class="nc" id="L558">    return new SequenceN&lt;&gt;(e1, e2, e3, e4, e5, e6, e7, e8, e9, e10);</span>
  }

  /**
   * Returns an unmodifiable sequence containing an arbitrary number of items.
   *
   * @param &lt;T&gt;
   *          the {@code ISequence}'s item type
   * @param items
   *          the items to be contained in the list
   * @return an {@code ISequence} containing the specified items
   * @throws NullPointerException
   *           if an item is {@code null} or if the array is {@code null}
   */
  @SafeVarargs
  @NonNull
  static &lt;T extends IItem&gt; ISequence&lt;T&gt; of(@NonNull T... items) {
<span class="fc bfc" id="L575" title="All 2 branches covered.">    return items.length == 0 ? empty() : new SequenceN&lt;&gt;(items);</span>
  }

  /**
   * Returns an unmodifiable sequence containing the items of the given
   * Collection, in its iteration order. The given Collection must not be null,
   * and it must not contain any null items. If the given Collection is
   * subsequently modified, the returned array item will not reflect such
   * modifications.
   *
   * @param &lt;T&gt;
   *          the {@code ISequence}'s item type
   * @param collection
   *          a {@code Collection} from which items are drawn, must be non-null
   * @return an {@code ISequence} containing the items of the given
   *         {@code Collection}
   * @throws NullPointerException
   *           if collection is null, or if it contains any nulls
   * @since 10
   */
  @SuppressWarnings(&quot;unchecked&quot;)
  @NonNull
  static &lt;T extends IItem&gt; ISequence&lt;T&gt; copyOf(Collection&lt;? extends T&gt; collection) {
<span class="nc bnc" id="L598" title="All 2 branches missed.">    return collection instanceof IArrayItem</span>
<span class="nc" id="L599">        ? (ISequence&lt;T&gt;) collection</span>
<span class="nc bnc" id="L600" title="All 2 branches missed.">        : collection.isEmpty()</span>
<span class="nc" id="L601">            ? empty()</span>
<span class="nc" id="L602">            : new SequenceN&lt;&gt;(new ArrayList&lt;&gt;(collection));</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>